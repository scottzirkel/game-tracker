# Live updates for the scoreboard

## Goal
- Ensure the scoreboard reflects the latest Overwatch game state without manual refreshes by supporting both Server-Sent Events (SSE) and a safe polling fallback.

## Current situation
- `src/app/scoreboard/page.tsx` already performs an initial fetch to `/api/state` and listens to `/api/stream` via `EventSource`, but there is no resilience if the stream fails or if the Overwatch service only exposes a polling endpoint.
- The Overwatch page (and API) sets the canonical state that the scoreboard needs to mirror in near-real time.
- We do not have a shared abstraction for consuming state updates, so any new client needs to re-implement fetch/SSE logic manually.

## Requirements & constraints
- Scoreboard must update within ~2 seconds of a change when SSE is available; fallback should poll at a configurable interval (default 5s) when SSE is not available or errors.
- Must continue to function in kiosk displays that may block EventSource or lose network temporarily.
- Changes should not break existing `/api/state` and `/api/stream` contracts relied on by Overwatch editor UI.

## Proposed approach
1. Extract a reusable `useScoreState` hook (e.g. `src/lib/hooks/useScoreState.ts`) that encapsulates initial load, SSE subscription, and optional polling fallback. **Model**: reasoning-heavy (GPT-4.1 or equivalent) for API design.
2. Enhance the hook to detect and recover from dropped SSE connections (retry with backoff, then fall back to polling after N failures). **Model**: reasoning-heavy to design retry state machine.
3. Expose configuration options for polling interval and SSE enablement to support future pages (Overwatch, tests). **Model**: coding-focused (Codex-style) once interface agreed.
4. Update scoreboard page to consume the hook instead of managing its own `useEffect` logic. **Model**: coding-focused (Codex-style) for refactor.
5. (Optional) Update Overwatch page to reuse the hook for consistency once stabilized. **Model**: coding-focused (Codex-style) with light reasoning.

## Implementation steps
1. **Audit APIs**: Confirm payload shape of `/api/state` and `/api/stream`, including heartbeat frequency and error handling expectations. **Model**: lightweight (GPT-4o-mini) for documentation review.
2. **Design hook API**: Draft TypeScript interface (state value + status flags + controls) and decide on retry/polling strategy (e.g. exponential backoff for SSE reconnects, capped at 30s). **Model**: reasoning-heavy (GPT-4.1) to balance ergonomics and resilience.
3. **Implement hook**:
   - Initial load via `fetch('/api/state')`.
   - Establish `EventSource` when enabled; on message, update state.
   - Handle `error` and `close` events: attempt reconnect a limited number of times, then start polling via `setInterval`.
   - Allow returning to SSE after a successful polling attempt triggers a new successful EventSource connection.
   - Surface status (`"idle" | "sse" | "polling" | "error"`) for UI/monitoring.
   **Model**: coding-focused (Codex-style) supported by GPT-4o for edge-case reasoning.
4. **Integrate with scoreboard**: Replace inline logic in `ScoreboardPage` with the hook, adding any status indicators (e.g. subtle badge when in polling mode). **Model**: coding-focused (Codex-style) with UI familiarity.
5. **Testing**: Write unit/integration tests for the hook (Jest/React Testing Library) mocking fetch/EventSource, and run manual verification in dev by toggling SSE availability. **Model**: reasoning + coding hybrid (GPT-4.1) for test coverage design.
6. **Docs & cleanup**: Document behavior in `src/lib/README.md` or a dedicated doc, and ensure any new env flags are reflected in `.env.example` if introduced. **Model**: lightweight drafting (GPT-4o-mini).

## Validation plan
- Automated: `npm run lint`, targeted unit tests for the hook, and (if fast) a scoreboard page rendering test. **Model**: coding-focused to script tests, lightweight for command execution.
- Manual:
  - Start Overwatch editor, make score changes, observe scoreboard updates instantly (SSE path).
  - Simulate SSE failure (disable `/api/stream` or use devtools offline) and confirm polling takes over and resumes once SSE is back.
  **Model**: human/manual; optional GPT-4o-mini to draft QA checklist.

## Open questions
- Does `/api/stream` already push heartbeats we can use for connection health, or do we need to add them? **Model**: reasoning-heavy to analyze current implementation.
- Should polling requests include ETag/If-None-Match to reduce payload, or is payload size negligible? **Model**: reasoning + data review (GPT-4.1).
- Do kiosk deployments require configurable URLs or auth headers for these endpoints? **Model**: lightweight documentation review (GPT-4o-mini).
